# 设计模式

## 项目地址："D:\java-project\DesignPatterns"

# 1.创建者模式

## 1.1 单例设计模式

### 1.1.1 饿汉式

+ 实现方式：静态成员变量的方式，静态代码块的方式，枚举方式
+ 静态成员变量的方式

```java
package pattern.singleton.demo1;


/**
 * 饿汉式，静态成员变量的方式
 */

/**
 * 私有的构造方法使得外界无法直接创建该类对象，为了使得外界能够获得该类对象，提供一个公共的获取对象的方法，这个方式必须是静态的，因为无法创建类对象。静态方法无法直接调类中的非静态成员变量
 */
public class Singleton {


    //1。私有构造方法。
    private Singleton(){}

    //2.在本类中创建本类对象
    private static Singleton instance=new Singleton();

    //3.提供一个公共的访问方式，让外界获取该对象
    public static Singleton getInstance(){
        return instance;
    }


}
```

```java
package pattern.singleton.demo1;

public class Client {
    public static void main(String[] args) {
        //创建Singleton类的对象
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();

        System.out.println(instance2==instance1);
    }
}
```

运行结果为true，这说明这种方式的的对象只会创建一次。

+ 静态代码块的方式

```java
package pattern.singleton.demo2;


/**
 * 饿汉式，静态代码块
 */
public class Singleton {

    //私有构造方法
    private Singleton() {
    }

    //声明Singleton类型的属性
    private static Singleton instance;//null，定义属性时没有赋值，而是在静态代码块中赋值

    static {
        instance = new Singleton();
    }

    //创建公共的可以调用instance的方法
    public static Singleton getInstance() {
        return instance;
    }

}
```

```java
package pattern.singleton.demo2;

public class Client {
    public static void main(String[] args) {

        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();

        System.out.println(instance1==instance2);//==判断对象地址是否相等
    }
}
```

运行结果同样是true。

+ 枚举方式

```java
package pattern.singleton.demo6;

public enum Singleton {
    INSTANCE
}
```

+ 总结

饿汉式在类加载时就会创建类对象，如果不使用就会一直在内存中存放。



### 1.1.2 懒汉式

+ 实现方式：线程不安全的方式和线程安全的方式，双重检查锁方式，静态内部类方式
+ 线程不安全的方式

````java
package pattern.singleton.demo3;

/**
 * 懒汉式：线程不安全的方式
 */
public class Singleton {

    //私有构造方法
    private Singleton(){}

    //声明Singleton类型的变量instance
    private static Singleton instance;

    //对外提供返回方式
    public  static Singleton getInstance(){

        //这里判断，如果已经有了Singleton对象，就直接返回，否则直接new
        if(instance ==null){

            /**
             * 这里会有线程冲突的问题，当线程1、线程2同时执行时，当线程1占用cpu时，此处instance==null，假设线程2占用cpu，线程1卡住，判断       instance=null.
             * 可能导致的结果时，new了两次。
             */
            return new Singleton();
        }
        return instance;
    }
}
````

```java
package pattern.singleton.demo3;

public class Client {
    public static void main(String[] args) {
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1==instance2);
    }
}
```

可能产生的问题是，线程不安全，加入关键字即可解决。

```java
public synchronized static Singleton getInstance()
```

+ 双重检查锁方式

````java
package pattern.singleton.demo4;

public class Singleton {

    //私有构造方法
    private Singleton(){}

    //声明Singleton类型的变量
    private static Singleton instance;

    //提供公共的访问方式
    public static Singleton getInstance(){

        //第一次判断，如果instance的值不为null，就可以直接返回对象
        if(instance==null){
            synchronized (Singleton.class){
                if(instance==null){
                    instance=new Singleton();
                }
            }
        }
        return instance;
    }
}

````

synchronize锁住的是对象，只有当一个线程执行完成后，其他线程才能执行被锁住的方法。

+ 静态内部类方式

jvm加载时不会加载静态内部类，只有内部类的方法或者属性被调用才会加载，并初始化其静态属性。

```java
package pattern.singleton.demo5;

/**
 * 静态内部类方式
 */
public class Singleton {

    //私有构造方法
    private Singleton(){}

    //定义一个静态内部类
    private static class SingletonHolder{

        //在内部类中声明并初始化外部类的对象
        private static final Singleton InSTANCE=new Singleton();//被final修饰就是常量
    }

    //提供公共的访问方式
    //当外界调用Singleton.getInstance方法时，才开始创建SingletonHolder对象并初始化INSTANCE
    public static Singleton getInstance(){
        return SingletonHolder.InSTANCE;
    }
}
```



### 1.1.3 存在的问题

破坏单例模式：通过某些方法或者手段，使得上面中的单例类能够创建多个对象。（除了枚举方法）

+ 破坏方法：序列化及反序列化方法、反射破坏法
+ 序列化及反序列化法：

```java
package pattern.singleton.demo7;


import java.io.*;

/**
 * 通过序列化和反序列话的方式破坏单例模式
 */
public class Client {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        writeObject2File();
        readObjectFile();
        readObjectFile();
    }

    public static void writeObject2File() throws IOException {

        //创建文件输出流
        ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream("C:\\Users\\shuai\\Desktop\\a.txt"));
        oos.writeObject(Singleton.getInstance());
        oos.close();
    }

    public static void readObjectFile() throws IOException, ClassNotFoundException {
        //创建文件输入流
        ObjectInputStream ois=new ObjectInputStream(new FileInputStream("C:\\Users\\shuai\\Desktop\\a.txt"));
        Singleton object = (Singleton)ois.readObject();
        System.out.println(object);
        ois.close();
    }
}
```

输出结果：![](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230716133701648.png)

表示是不同的对象了。

+ 反射破坏法：

```Java
package pattern.singleton.demo8;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Client {
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        //1，获取字节码对象
        Class clazz=Singleton.class;
        //2，获取无参构造方法
        Constructor constructor = clazz.getDeclaredConstructor();

        //3，由于这个无参构造方法是私有的，所以需要对无参构造取消访问检查
        constructor.setAccessible(true);

        //4，创建Singleton对象
        Singleton instance1 = (Singleton) constructor.newInstance();
        Singleton instance2 = (Singleton) constructor.newInstance();
        System.out.println(instance1 == instance2);
    }
}
```

结果：false，表示破坏了单例模式。

### 1.1.4 单例模式在源码中的应用

java.lang.Runtime：经典饿汉式

![image-20230716145008932](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230716145008932.png)



## 1.2 工厂模式

### 1.2.1 普通模式

+ 以点咖啡制作为例，没有使用设计模式的解决方案

```java
package pattern.factory.simpleFactory.coffee;

/**
 * 咖啡抽象父类
 */
public abstract class Coffee {

    public abstract String getName();

    public void addSugar(){
        System.out.println("加糖");
    }

    public void addMilk(){
        System.out.println("加奶");
    }
}
```

创建两种咖啡子类：

```java
package pattern.factory.simpleFactory.coffee;

/**
 * 创建美式咖啡子类
 */
public class AmericanCoffee extends Coffee{
    @Override
    public String getName() {
        return "美式咖啡";
    }
}
```

```java
package pattern.factory.simpleFactory.coffee;

/**
 * 创建拿铁咖啡子类
 */
public class LatteCoffee extends Coffee{
    @Override
    public String getName() {
        return "拿铁咖啡";
    }
}
```

创建咖啡店类：

```java
package pattern.factory.simpleFactory.coffee;

/**
 * 咖啡店用于订购咖啡
 */
public class CoffeeStore {

    //根据类型订购咖啡
    public Coffee orderCoffee(String type){

        Coffee coffee;
        if("american".equals(type)){
            coffee=new AmericanCoffee();
        }else if("latte".equals(type)){
            coffee=new LatteCoffee();
        }else{
            throw new RuntimeException("对不起，还没有这种类型的咖啡");
        }

        //加配料
        coffee.addSugar();
        coffee.addMilk();
        return coffee;
    }
}
```

客户端运行：

```java
package pattern.factory.simpleFactory.coffee;

public class Client {
    public static void main(String[] args) {

        CoffeeStore coffeeStore = new CoffeeStore();
        Coffee coffee = coffeeStore.orderCoffee("latte");
        System.out.println(coffee.getName());
    }
}
```

**产生的问题**：违背了开闭原则，要新增咖啡种类的话，需要修改咖啡店的代码，而且咖啡店和具体咖啡耦合度太高。



### 1.2.2 简单工厂模式

简单工厂三大角色：

+ 抽象产品：定义产品的规范，描述产品主要的定义和功能
+ 具体产品：实现或者继承抽象产品的子类
+ 具体工厂：提供创建产品的方法，获取产品对象。

简单工厂模式只是在简单工厂模式基础上，添加了一个创建咖啡的工厂，降低了咖啡店和咖啡之间的耦合，将耦合转移到工厂和咖啡之间。

咖啡工厂类：

```java
package pattern.factory.simpleFactory;


//咖啡工厂能够生产咖啡
public class SimpleCoffeeFactory {

    public Coffee createCoffee(String type){

        Coffee coffee;
        if("american".equals(type)){
            coffee= new AmericanCoffee();
        }else if("latte".equals(type)){
            coffee=new LatteCoffee();
        }else{
            throw new RuntimeException("抱歉，你点的咖啡种类没有");
        }

        return coffee;
    }
}
```



+ 优缺点：

优点：加了一层封装，可以避免修改用户端代码，以后只需要修改工厂类。

缺点：还是需要修改工厂类代码，违背开闭原则。



+ 拓展：静态工厂模式

将工厂类中的方法设置为静态方法，免去了创建工厂对象的步骤。

```java
public class SimpleCoffeeFactory {

    public static Coffee createCoffee(String type){
```

```java
package pattern.factory.staticSimpleFactory;

public class CoffeeStore {

    public void orderCoffee(String type){
//        SimpleCoffeeFactory simpleCoffeeFactory = new SimpleCoffeeFactory();
//        Coffee coffee = simpleCoffeeFactory.createCoffee(type);
        Coffee coffee = SimpleCoffeeFactory.createCoffee(type);

        //加配料
        coffee.addMilk();
        coffee.addSugar();
        System.out.println(coffee.getName());
    }
}
```



### 1.2.3 工厂方法模式

抽象的咖啡工厂类，用接口表示：

```java
package pattern.factory.factory_method;

/**
 * 属于抽象工厂角色
 */
public interface CoffeeFactory {

    Coffee createCoffee();
}
```

定义具体的咖啡工厂类，每种工厂只生产一种特定的咖啡：

```java
package pattern.factory.factory_method;

/**
 * 美式咖啡具体工厂对象
 */
public class AmericanCoffeeFactory implements CoffeeFactory{
    @Override
    public Coffee createCoffee() {
        return new AmericanCoffee();
    }
}
```

```java
package pattern.factory.factory_method;

/**
 * 拿铁咖啡具体工厂对象
 */
public class LatteCoffeeFactory implements CoffeeFactory{
    @Override
    public Coffee createCoffee() {
        return new LatteCoffee();
    }
}
```

咖啡店通过抽象的咖啡工厂订购咖啡：

```java
package pattern.factory.factory_method;

/**
 * @ClassName CoffeeStore
 * @Author rein
 * @create 2023/7/17 9:44
 */
public class CoffeeStore {

    private CoffeeFactory coffeeFactory;

    //通过set方法设置具体咖啡工厂类型
    public void setCoffeeFactory(CoffeeFactory coffeeFactory){
        this.coffeeFactory=coffeeFactory;
    }

    public Coffee orderCoffee(){
        Coffee coffee = coffeeFactory.createCoffee();
        coffee.addMilk();
        coffee.addSugar();
        return coffee;
    }
}
```

客户端验证：

```java
package pattern.factory.factory_method;



/**
 * @ClassName Client
 * @Author rein
 * @create 2023/7/17 9:50
 */
public class Client {
    public static void main(String[] args) {

        //实现订购咖啡功能
        CoffeeStore coffeeStore = new CoffeeStore();
        coffeeStore.setCoffeeFactory(new AmericanCoffeeFactory());//这里选择具体的咖啡工厂
        Coffee coffee = coffeeStore.orderCoffee();
        System.out.println(coffee.getName());
    }
}
```



+ 优缺点：

优点：用户通过具体咖啡工厂具体名称就可以知道点哪种咖啡，不用知道具体过程。

​            当咖啡店新增咖啡种类时，只需要添加具体咖啡类和具体咖啡工厂类，只添加代码，不修改代码，满足开闭原则。

缺点：需要添加很多类，增加了复杂度。



## 1.3 建造者模式

创建自行车案例，包含车架、车座的生产及组装。大体分成以下几种角色：产品类（由各种零件组装而成）、构建者抽象类（用于创建自行车各种部件）、构建者具体类（继承自抽象类，创建具体型号自行车的具体部件）、指挥者类（决定构建者生产的部件的组装细节、顺序等）

自行车类：

```java
package pattern.builder.demo1;

/**
 * @ClassName Bike
 * @Author shuai
 * @create 2023/7/17 15:16
 * @Instruction 自行车产品类
 */
public class Bike {

    private String frame;//车架

    private String seat;//车座

    public String getFrame() {
        return frame;
    }

    public void setFrame(String frame) {
        this.frame = frame;
    }

    public String getSeat() {
        return seat;
    }

    public void setSeat(String seat) {
        this.seat = seat;
    }
}
```

构建者抽象类，由于携带Bike类型的属性，所有没有设置成接口：

```java
package pattern.builder.demo1;

/**
 * @ClassName Builder
 * @Author shuai
 * @create 2023/7/17 15:20
 * @Instruction 构建者类
 */
public abstract class Builder {

    //声明bike类型的对象并赋值
    protected Bike bike=new Bike();

    //构建车架
    public abstract void buildFrame();

    //构建座椅
    public abstract void buildSeat();

    //构建自行车的方法
    public abstract Bike createBike();
}
```

构建者具体类，为不同型号自行车生产组件：

```java
package pattern.builder.demo1;

/**
 * @ClassName MobileBike
 * @Author shuai
 * @create 2023/7/17 15:29
 * @Instruction 具体的构建者：用来构建摩拜单车对象
 */
public class MobileBuilder extends Builder{
    @Override
    public void buildFrame() {
        bike.setFrame("摩拜单车车架");
    }

    @Override
    public void buildSeat() {
        bike.setSeat("摩拜单车座椅");
    }

    @Override
    public Bike createBike() {
        return bike;
    }
}
```

```java
package pattern.builder.demo1;

/**
 * @ClassName OfoBuilder
 * @Author shuai
 * @create 2023/7/17 15:46
 * @Instruction 具体构建者，用来构建ofo单车对象
 */
public class OfoBuilder extends Builder{
    @Override
    public void buildFrame() {
        bike.setFrame("ofo单车车架");
    }

    @Override
    public void buildSeat() {
        bike.setSeat("ofo单车座椅");
    }

    @Override
    public Bike createBike() {
        return bike;
    }
}
```

指挥者类：

```java
package pattern.builder.demo1;

/**
 * @ClassName Director
 * @Author shuai
 * @create 2023/7/17 15:50
 * @Instruction 指挥者类
 */
public class Director {

    private Builder builder;

    public Director(Builder builder){
        this.builder=builder;
    }

    //组装自行车
    public Bike construct(){
        //执行装备车架、车座
        builder.buildSeat();
        builder.buildFrame();
        return builder.createBike();
    }
}
```

客户端：

```java
package pattern.builder.demo1;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/17 17:25
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {

        MobileBuilder mobileBuilder = new MobileBuilder();
        Director director = new Director(mobileBuilder);
        Bike bike = director.construct();
        System.out.println(bike.getFrame());
        System.out.println(bike.getSeat());
    }
}
```



+ 优缺点：

  优点：

  + 封装性很好
  + 将产品和产品创建过程解耦，使得相同的创建过程创建不同的对象。
  + 将复杂产品的创建步骤分解在不同的方法中
  + 容易拓展，符合开闭原则

  缺点：

  + 建造者模式适用于同类产品，如果产品差异过大则不适用。

+ 使用场景

  + 创建的对象较复杂，由多个部件组成，但构建的构造顺序确定
  + 创建复杂对象的算法独立于该对象的组成部分及装配方式

  

### 1.3.1 建造者模式拓展

一个电脑产品的生产过程重构前代码如下：

```java
package pattern.builder.demo2;

/**
 * @ClassName Computer
 * @Author shuai
 * @create 2023/7/18 9:39
 * @Instruction 电脑类
 */
public class Computer {
    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    public Computer(String cpu, String screen, String memory, String mainboard) {
        this.cpu = cpu;
        this.screen = screen;
        this.memory = memory;
        this.mainboard = mainboard;
    }

    public String getCpu() {
        return cpu;
    }

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    public String getScreen() {
        return screen;
    }

    public void setScreen(String screen) {
        this.screen = screen;
    }

    public String getMemory() {
        return memory;
    }

    public void setMemory(String memory) {
        this.memory = memory;
    }

    public String getMainboard() {
        return mainboard;
    }

    public void setMainboard(String mainboard) {
        this.mainboard = mainboard;
    }

    @Override
    public String toString() {
        return "Computer{" +
                "cpu='" + cpu + '\'' +
                ", screen='" + screen + '\'' +
                ", memory='" + memory + '\'' +
                ", mainboard='" + mainboard + '\'' +
                '}';
    }
}
```

```java
package pattern.builder.demo2;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/18 9:41
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {
        Computer computer = new Computer("intel","三星屏幕","金士顿","华硕");
        System.out.println(computer);
    }
}
```



存在的问题：当有新的组件需要添加时，需要修改构造方法，toString()等方法，违反了开闭原则。

通过内部类的建造者模式重构后：

```java
package pattern.builder.demo3;

/**
 * @ClassName Computer
 * @Author shuai
 * @create 2023/7/18 9:51
 * @Instruction
 */
public class Computer {

    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    //提供私有的构造方法，防止外界直接创建对象
    private Computer(Builder builder){
        this.cpu=builder.cpu;
        this.screen=builder.screen;
        this.memory=builder.memory;
        this.mainboard=builder.mainboard;
    }

    //将构建者通过内部类的方式创建
    public static final class Builder{
        private String cpu;
        private String screen;
        private String memory;
        private String mainboard;

        //对每个组件都创建一个构建者
        public Builder cpu(String cpu){
            this.cpu=cpu;
            return this;
        }
        public Builder screen(String screen){
            this.screen=screen;
            return this;
        }
        public Builder memory(String memory){
            this.memory=memory;
            return this;
        }
        public Builder mainboard(String mainboard){
            this.mainboard=mainboard;
            return this;
        }


        //使用构建者创建Computer对象
        public Computer build(){
            return new Computer(this);
        }

        @Override
        public String toString() {
            return "Builder{" +
                    "cpu='" + cpu + '\'' +
                    ", screen='" + screen + '\'' +
                    ", memory='" + memory + '\'' +
                    ", mainboard='" + mainboard + '\'' +
                    '}';
        }
    }
}
```

```java
package pattern.builder.demo3;


/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/18 10:01
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {

        /**
         * 链式编程，要求中间每一步函数的返回值都是该对象
         */
        Computer computer=new Computer.Builder()
                .cpu("intel")
                .memory("金士顿")
                .screen("三星屏幕")
                .mainboard("华硕")
                .build();

        System.out.println(computer);
    }
}
```

**可读性高，但是对程序员要求更高**




# 2.结构型模式

## 2.1 适配器模式

将某个类的接口转换成客户端期望的另一种接口表示，主要的目的是做**兼容**。



### 2.1.1 类适配器

Adapter类，通过继承src类，实现dst类接口，完成src->dst的适配。

![image-20230718103525203](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230718103525203.png)

要被适配的类：

```java
package adapter.class_adapter;

/**
 * @ClassName Voltage220V
 * @Author shuai
 * @create 2023/7/18 10:37
 * @Instruction 输出220V电压，手机不能直接使用
 */
public class Voltage220V {
    public int output220V(){
        int src=220;
        return src;
    }
}
```

目标接口：

```java
package adapter.class_adapter;

/**
 * @ClassName IVoltage5V
 * @Author shuai
 * @create 2023/7/18 10:40
 * @Instruction 要转成5V的接口
 */
public interface IVoltage5V {
    int output5V();
}
```

类适配器：

```java
package adapter.class_adapter;

/**
 * @ClassName VoltageAdapter
 * @Author shuai
 * @create 2023/7/18 10:42
 * @Instruction
 */
public class VoltageAdapter extends Voltage220V implements IVoltage5V{
    @Override
    public int output5V() {
        int srcV=output220V();
        int dstV=srcV/44;//转成5V
        return dstV;
    }
}
```

手机类：

```java
package adapter.class_adapter;

/**
 * @ClassName Phone
 * @Author shuai
 * @create 2023/7/18 10:48
 * @Instruction 手机冲电
 */
public class Phone {

    public void charging(IVoltage5V iVoltage5V){
        int dst=iVoltage5V.output5V();
        if(dst==5){
            System.out.println("可以充电");
        }else if(dst>5){
            System.out.println("电压大于5V，不能充电");
        }
    }
}
```

客户端：

```java
package adapter.class_adapter;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/18 10:50
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter());//传入实现接口的类（多态）
    }
}
```

+ 优缺点

![image-20230718105735851](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230718105735851.png)



### 2.1.2 对象适配器

+ 基本思路同类适配器，但是adapter类没有继承src类，而是持有src类的实例
+ 在系统中尽量通过关联关系来代替继承关系
+ 对象适配器在适配器模式中很常用

只需要改动VoltageAdapter代码：

```java
package adapter.object_adapter;

/**
 * @ClassName VoltageAdapter
 * @Author shuai
 * @create 2023/7/19 10:05
 * @Instruction 采用对象适配器的方式
 */
public class VoltageAdapter implements IVoltage5V{

    private Voltage220V voltage220V;

    public VoltageAdapter(Voltage220V voltage220V){
        this.voltage220V=voltage220V;
    }

    @Override
    public int output5V() {
        int src = voltage220V.output220V();
        int dst=src/44;
        return dst;
    }
}
```

客户端代码：

```java
package adapter.object_adapter;



/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/19 10:08
 * @Instruction
 */
public class Client {

    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter(new Voltage220V()));
    }
}
```



### 2.1.3 接口适配器

当不需要实现接口中所有的方法时，可以用抽象类实现接口，并为接口中每个方法提供默认实现，那么抽象类的子类可以有选择地覆盖父类中的某些方法。

```java
package adapter.interface_adapter;

/**
 * @ClassName Interface
 * @Author shuai
 * @create 2023/7/19 10:56
 * @Instruction
 */
public interface I {

    void m1();
    void m2();
    void m3();
    void m4();
}
```

```java
package adapter.interface_adapter;

/**
 * @ClassName AbsAdapter
 * @Author shuai
 * @create 2023/7/19 11:04
 * @Instruction 抽象类实现接口中所有方法
 */
public abstract class AbsAdapter implements I {
    @Override
    public void m1() {}//唯一需要被使用的方法

    @Override
    public void m2() {}

    @Override
    public void m3() {}

    @Override
    public void m4() {}
}
```

```java
package adapter.interface_adapter;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/19 11:05
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {

        AbsAdapter absAdapter=new AbsAdapter() {
            @Override
            public void m1() {
                System.out.println("匿名内部类实现m1");
            }
        };

        absAdapter.m1();

        System.out.println(absAdapter.getClass());
    }
}
```

+ 匿名内部类：有特定的语法格式，运行类型可以是接口、抽象类等。创建的匿名内部类对象只会被使用一次。



### 2.1.4 Dispatcher源码分析

**Springmvc**执行流程：

+ 前端发送来一个请求登录login，发送给服务器tomcat，经过DispatcherServlet处理。
+ DispatchServlet有一个HandlerMapping，它会根据发送过来的请求，匹配对应的Handler。
+ 执行对应Handler对应的方法。
+ 方法返回一个结果ModelAndView。
+ 将ModelAndView返回前端解析

Controller类：

```java
package adapter.springmvc;

/**
 * @ClassName Controller
 * @Author shuai
 * @create 2023/7/19 15:32
 * @Instruction
 */
public interface Controller {
}
```

```java
package adapter.springmvc;

/**
 * @ClassName AnnotationController
 * @Author shuai
 * @create 2023/7/19 15:36
 * @Instruction
 */
public class AnnotationController implements Controller{
    public void doAnnotationController(){
        System.out.println("AnnotationController");
    }
}
```

```java
package adapter.springmvc;

/**
 * @ClassName HttpController
 * @Author shuai
 * @create 2023/7/19 15:35
 * @Instruction
 */
public class HttpController implements Controller{

    public void doHttpController(){
        System.out.println("HttpController");
    }
}
```

```java
package adapter.springmvc;

/**
 * @ClassName SimpleController
 * @Author shuai
 * @create 2023/7/19 15:34
 * @Instruction
 */
public class SimpleController implements Controller{

    public void doSimpleController(){
        System.out.println("httpController");
    }
}
```

handlerAdapter类：

```java
package adapter.springmvc;

/**
 * @ClassName HandlerAdapter
 * @Author shuai
 * @create 2023/7/19 15:38
 * @Instruction
 */
public interface HandlerAdapter {

    //handler和Controller可以理解成一样

    void handle(Object handler);

    boolean supports(Object handler);
}
```

```java
package adapter.springmvc;

/**
 * @ClassName AnnotationHandlerAdapter
 * @Author shuai
 * @create 2023/7/19 15:39
 * @Instruction
 */
public class AnnotationHandlerAdapter implements HandlerAdapter{
    @Override
    public void handle(Object handler) {
    }

    @Override
    public boolean supports(Object handler) {
        return (handler instanceof AnnotationHandlerAdapter);
    }
}
```

```java
package adapter.springmvc;

/**
 * @ClassName HttpHandlerAdapter
 * @Author shuai
 * @create 2023/7/19 15:40
 * @Instruction
 */
public class HttpHandlerAdapter implements HandlerAdapter{
    @Override
    public void handle(Object handler) {

    }

    @Override
    public boolean supports(Object handler) {
        return (handler instanceof HttpHandlerAdapter);
    }
}
```

```java
package adapter.springmvc;

/**
 * @ClassName SimpleHandlerAdapter
 * @Author shuai
 * @create 2023/7/19 15:40
 * @Instruction
 */
public class SimpleHandlerAdapter implements HandlerAdapter{
    @Override
    public void handle(Object handler) {
        ((SimpleController)handler).doSimpleController();
    }

    @Override
    public boolean supports(Object handler) {
        return (handler instanceof SimpleController);
    }
}
```

DispatchServlet：

```java
package adapter.springmvc;

import java.util.ArrayList;
import java.util.List;

/**
 * @ClassName DispatchServlet
 * @Author shuai
 * @create 2023/7/19 15:42
 * @Instruction
 */
public class DispatchServlet {

    public static List<HandlerAdapter> handlerAdapters = new ArrayList<>();

    public DispatchServlet() {
        handlerAdapters.add(new AnnotationHandlerAdapter());
        handlerAdapters.add(new SimpleHandlerAdapter());
        handlerAdapters.add(new HttpHandlerAdapter());
    }

    public void doDispatch() {

        //此处模拟springmvc从request获取的handler对象
        AnnotationController controller = new AnnotationController();

        //通过controller获取对应的adapter
        HandlerAdapter handler = getHandler(controller);//annotationHandlerAdapter
        handler.handle(controller);

    }

    public HandlerAdapter getHandler(Controller controller) {
        //根据controller返回对应的adapter类
        for (HandlerAdapter handlerAdapter : handlerAdapters
        ) {
            if (handlerAdapter.supports(controller)) {
                return handlerAdapter;
            }
        }

        throw new RuntimeException("没有匹配的适配器");
    }
}
```

**适配器模式是通过传入的controller类型，产生对应的handler对象，从而调用不同的方法**



## 2.2 代理模式

通过代理对象访问目标对象，可以在目标对象实现的基础上，增强额外的功能操作。

### 2.2.1 静态代理

被代理的对象和代理对象实现公共的接口或者相同的父类。

![image-20230720095654397](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230720095654397.png)

公共的代理接口：

```java
package pattern.proxy.static_proxy;

/**
 * @ClassName ITeacherDao
 * @Author shuai
 * @create 2023/7/20 9:57
 * @Instruction
 */
public interface ITeacherDao {


    void teach();
}
```

被代理对象：

```java
package pattern.proxy.static_proxy;

/**
 * @ClassName TeacherDao
 * @Author shuai
 * @create 2023/7/20 9:58
 * @Instruction
 */
public class TeacherDao implements ITeacherDao{

    @Override
    public void teach() {
        System.out.println("老师上课");
    }
}
```

代理对象（将被代理对象传递给代理对象）：

```java
package pattern.proxy.static_proxy;

/**
 * @ClassName TeacherDaoProxy
 * @Author shuai
 * @create 2023/7/20 9:59
 * @Instruction
 */
public class TeacherDaoProxy implements ITeacherDao{

    //通过接口聚合TeacherDao
    private ITeacherDao target;

    public TeacherDaoProxy(ITeacherDao teacherDao){
        this.target=teacherDao;
    }
    @Override
    public void teach() {
        //这里可以实现对功能的拓展
        System.out.println("代理开始");
        target.teach();
        System.out.println("代理结束");
    }
}
```

客户端（代理对象执行目标对象的方法）：

```java
package pattern.proxy.static_proxy;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/20 9:59
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {
        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(new TeacherDao());
        teacherDaoProxy.teach();
    }
}
```

![image-20230720101009228](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230720101009228.png)



### 2.2.2 动态代理

代理工厂，用于生产代理类：

```java
package pattern.proxy.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @ClassName ProxyFactory
 * @Author shuai
 * @create 2023/7/20 16:08
 * @Instruction 用于生成动态代理对象
 */
public class ProxyFactory {

    private ITeacherDao teacherDao=new TeacherDao();

    public ITeacherDao getProxyObject(){

        /**
         * public static Object newProxyInstance(ClassLoader loader, //类加载器
         *                                           Class<?>[] interfaces,//代理类实现的接口的字节码对象
         *                                           InvocationHandler h)//代理对象的调用处理程序，其中InvocationHandler是一个接口，可以传入它的实现类
         */
        ITeacherDao proxyInstance = (ITeacherDao) Proxy.newProxyInstance(
                teacherDao.getClass().getClassLoader(),
                teacherDao.getClass().getInterfaces(),

                //动态代理关键的方法，在这里进行业务逻辑的处理
                new InvocationHandler() {//匿名内部类的方式
                    @Override
                    /**
                     * Object proxy：代理对象，和proxyInstance是同一个对象，在invoke中基本不用
                     * Method method：对接口中方法进行封装的方法
                     * Object[] args：调用方法的实际参数
                     * 返回值：方法的返回值
                     */
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("代理开始");
                        //执行目标对象的方法
                        Object obj = method.invoke(teacherDao, args);
                        return obj;
                    }
                });
        return proxyInstance;
    }
}
```

```java
package pattern.proxy.dynamic;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/20 16:14
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {

        //通过代理对象工厂来获取代理对象
        ProxyFactory proxyFactory = new ProxyFactory();
        ITeacherDao proxyObject = proxyFactory.getProxyObject();
        proxyObject.teach();
    }
}
```

![image-20230720162838926](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230720162838926.png)

+ 解析

ProxyFactory不是代理类，而代理类是程序在运行过程中动态在内存中生成的类

代理类和真实类实现了相同的接口

代理类将匿名类传给了父类



### 2.2.3 cglib代理

静态代理和动态代理都需要实现接口，如果**没有定义这样的接口**则可以使用cglib代理。cglib代理使用方法类似于动态代理，只不过实现的细节略有差异。

```java
package pattern.proxy.cglib_proxy;

/**
 * @ClassName TeacherDao
 * @Author shuai
 * @create 2023/7/20 17:19
 * @Instruction
 */
public class TeacherDao {

    public void teach(){
        System.out.println("老师授课中");
    }
}
```

```java
package pattern.proxy.cglib_proxy;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * @ClassName ProxyFactory
 * @Author shuai
 * @create 2023/7/22 9:13
 * @Instruction 获取代理类，是目标对象所属类的子类（继承）
 */
public class ProxyFactory implements MethodInterceptor {

    //声明火车站对象
    private TeacherDao teacherDao=new TeacherDao();
    public TeacherDao getProxyObject(){
        //创建Enhancer类，类似于JDK中Proxy类
        Enhancer enhancer=new Enhancer();

        //设置父类的字节码对象
        enhancer.setSuperclass(TeacherDao.class);
        //设置回调函数
        enhancer.setCallback(this);//这个函数传递的是methodInterceptor子实现类的对象

        //创建代理对象
        TeacherDao proxyObject = (TeacherDao) enhancer.create();
        return proxyObject;
    }

    /**
     * @param o 代理对象
     * @param method 对应调用方法的method对象
     * @param objects 实际参数
     * @param methodProxy
     * @return
     * @throws Throwable
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("代理开始");

        //通过反射来执行方法
        Object obj = method.invoke(teacherDao, objects);//相当于调用teach，返回值null
//        teacherDao.teach();
        return obj;
    }
}
```



### 2.2.4 总结

+ 优点
  + 起到保护目标对象的作用
  + 拓展目标对象的功能
  + 解耦
+ 缺点

增加系统复杂度



## 2.3 装饰者模式

**在不改变现有结构的情况下，动态地给该对象增加额外的功能**

案例：快餐有炒饭炒粉等类型，炒饭炒粉又可以单独添加各种配料并且计算相应价格。

![image-20230722101906797](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230722101906797.png)

快餐店：

```java
package pattern.decorator;

/**
 * @ClassName FastFood
 * @Author shuai
 * @create 2023/7/22 10:20
 * @Instruction 快餐类，属于抽象构建角色
 */
public abstract class FastFood {

    private float price;//价格
    private String desc;//描述

    public FastFood(){

    }
    public FastFood(float price, String desc) {
        this.price = price;
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    //计算价格方法
    public abstract float cost();
}
```



快餐店售卖的炒饭和炒粉继承了快餐店类：

```java
package pattern.decorator;

/**
 * @ClassName FiredNoodles
 * @Author shuai
 * @create 2023/7/22 10:29
 * @Instruction 炒面，具体构建类
 */
public class FiredNoodles extends FastFood{

    public FiredNoodles(){
        super(12,"炒面");
    }
    @Override
    public float cost() {
        return getPrice();
    }
}
```

```java
package pattern.decorator;

/**
 * @ClassName FiredRice
 * @Author shuai
 * @create 2023/7/22 10:26
 * @Instruction 炒饭，具体构建角色
 */
public class FiredRice extends FastFood{

    //通过无参构造给父类的成员变量赋值
    public FiredRice(){
        super(10,"炒饭");
    }
    @Override
    public float cost() {
        return getPrice();
    }
}
```



装饰者角色，继承类父类，同时也将父类作为成员变量：

```java
package pattern.decorator;

/**
 * @ClassName Garnish
 * @Author shuai
 * @create 2023/7/22 10:30
 * @Instruction 装饰者类。抽象装饰角色
 */
public abstract class Garnish extends FastFood{

    //声明快餐类对象
    private FastFood fastFood;

    public Garnish(float price, String desc, FastFood fastFood) {
        super(price, desc);//调用父类的构造方法
        this.fastFood = fastFood;
    }

    public FastFood getFastFood() {
        return fastFood;
    }

    public void setFastFood(FastFood fastFood) {
        this.fastFood = fastFood;
    }
}
```



鸡蛋培根作为装饰继承抽象的装饰者类：

```java
package pattern.decorator;

/**
 * @ClassName Egg
 * @Author shuai
 * @create 2023/7/22 10:33
 * @Instruction 鸡蛋类，具体装饰者角色
 */
public class Egg extends Garnish {


    public Egg(FastFood fastFood) {
        super(1, "鸡蛋", fastFood);
    }

    @Override
    public float cost() {
        return getFastFood().getPrice() + getPrice();
    }

    @Override
    public String getDesc() {
        //super.getDesc()-炒饭或者炒粉
        //this.getDesc()-鸡蛋
        return super.getDesc()+getFastFood().getDesc();
    }
}
```

```java
package pattern.decorator;

/**
 * @ClassName Egg
 * @Author shuai
 * @create 2023/7/22 10:33
 * @Instruction 培根类，具体装饰者角色
 */
public class Bacon extends Garnish {


    public Bacon(FastFood fastFood) {
        super(2, "培根", fastFood);
    }

    @Override
    public float cost() {
        return getFastFood().getPrice() + getPrice();
    }

    @Override
    public String getDesc() {
        //super.getDesc()-培根
        return super.getDesc()+getFastFood().getDesc();
    }
}
```



客户端：

```java
package pattern.decorator;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/22 10:56
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {
        //点炒饭
        FastFood food = new FiredRice();
        System.out.println(food.getDesc() + "的价格是" + food.cost());
        System.out.println("---------------------------------------");

        //在上面的炒饭中加个鸡蛋
        food=new Egg(food);
        System.out.println(food.getDesc() + "的价格是" + food.cost());
    }
}
```

![image-20230723142820852](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230723142820852.png)



### 2.3.1 IO流源码

![image-20230723143827034](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230723143827034.png)

```java
package pattern.decorator;

import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

/**
 * @ClassName test
 * @Author shuai
 * @create 2023/7/23 14:40
 * @Instruction
 */
public class test {
    public static void main(String[] args) throws FileNotFoundException {
        DataInputStream dataInputStream = new DataInputStream(new FileInputStream("d:\\a.txt"));
        //FileInputStream的父类InputStream是一个抽象类，相当于快餐店
        //FileInputStream相当于炒饭，DataInputStream相当于鸡蛋，具体的装饰者
        //FileInputStream的父类FilterInputStream就是装饰者角色
    }
}
```

**装饰者类中有成员变量被装饰者**



### 2.3.2 总结

装饰者模式动态地将新功能增加到对象上



# 3.行为型模式

## 3.1 迭代器模式

案例：实现类似于迭代器的功能

学生类：

```java
package action.iterator;

/**
 * @ClassName Student
 * @Author shuai
 * @create 2023/7/24 17:38
 * @Instruction
 */
public class Student {

    private String name;
    private String number;

    public Student(String name, String number) {
        this.name = name;
        this.number = number;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", number='" + number + '\'' +
                '}';
    }
}
```



迭代器实现的两个方法（基本统一）：

```java
package action.iterator;

/**
 * @ClassName IStudentIterator
 * @Author shuai
 * @create 2023/7/24 20:30
 * @Instruction 抽象迭代器角色接口
 */
public interface IStudentIterator {

    //判断是否还有元素
    boolean hasNext();

    //获取下一个元素
    Student next();
}
```



迭代器实现类：

```java
package action.iterator;

import java.util.List;

/**
 * @ClassName StudentIterator
 * @Author shuai
 * @create 2023/7/24 20:32
 * @Instruction 迭代器角色类
 */
public class StudentIteratorImpl implements IStudentIterator{

    private List<Student> list;

    public StudentIteratorImpl(List<Student> list) {
        this.list = list;
    }

    private int position;//记录遍历时的位置
    @Override
    public boolean hasNext() {
        return position<list.size();
    }

    @Override
    public Student next() {
        //从集合中获取指定位置的元素
        Student currentStudent = list.get(position);
        position++;
        return currentStudent;
    }
}
```



聚合类接口（集合基本的增删等功能接口）：

```java
package action.iterator;

/**
 * @ClassName StudentAggregate
 * @Author shuai
 * @create 2023/7/24 20:37
 * @Instruction 抽象聚合角色
 */
public interface StudentAggregate {

    //添加学生功能
    void addStudent(Student stu);

    //删除学生功能
    void remStudent(Student stu);

    //获取迭代器对象功能
    StudentIteratorImpl getStudentIterator();
}
```



聚合类实现：

```java
package action.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * @ClassName StudentAggregateImpl
 * @Author shuai
 * @create 2023/7/24 20:41
 * @Instruction
 */
public class StudentAggregateImpl implements StudentAggregate{

    private List<Student> list=new ArrayList<>();
    @Override
    public void addStudent(Student stu) {
        list.add(stu);
    }

    @Override
    public void remStudent(Student stu) {
        list.remove(stu);
    }

    //获取迭代器对象
    @Override
    public StudentIteratorImpl getStudentIterator() {
        return new StudentIteratorImpl(list);
    }
}
```



客户端：

```java
package action.iterator;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/24 20:46
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {
        StudentAggregateImpl studentAggregate = new StudentAggregateImpl();
        studentAggregate.addStudent(new Student("张三","123"));
        studentAggregate.addStudent(new Student("李四","124"));
        studentAggregate.addStudent(new Student("王五","125"));
        StudentIteratorImpl studentIterator = studentAggregate.getStudentIterator();

        //遍历
        while(studentIterator.hasNext()){
            System.out.println(studentIterator.next());
        }

    }
}
```

![image-20230724210100004](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230724210100004.png)



### 3.1.1 优缺点

通过迭代器就可以改变集合遍历的方式，可以在迭代器中自定义决定。从而在聚合类中不需要定义遍历方法。但缺点就是会新增几个类。



### 3.1.2 使用场景

+ 为聚合对象提供多个遍历方式
+ 为不同聚合结构提供统一的接口
+ 访问一个聚合对象的内容无需细节展示



### 3.1.3 jdk源码解析

![image-20230724211915695](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230724211915695.png)



## 3.2 模板方法模式

### 3.2.1 介绍

某些时候流程的步骤时确定的，但是其中几个步骤的具体实现还不清楚，或者说跟具体环境相关。

比如银行办理业务流程：取号、排队、办理具体业务和给工作人员打分。其中办理具体业务不同，而其他步骤是统一的。**模板方法模式将这些具体实现推迟到子类中**。



### 3.2.2 炒菜案例

```java
package action.template;

/**
 * @ClassName AbstractClass
 * @Author shuai
 * @create 2023/7/24 21:41
 * @Instruction 抽象类，定义模板方法和基本方法
 */
public abstract class AbstractClass {

    //模板方法定义，规定了之后就不能变动，设置final
    public final void cookProcess(){
        pourOil();
        heatOil();
        pourVegetable();
        pourSauce();
        fry();
    }
    public void pourOil(){
        System.out.println("倒油");
    }

    public void heatOil(){
        System.out.println("热油");
    }

    //不同的菜倒不同的菜
    public abstract void pourVegetable();

    //不同的菜放的调料不同
    public abstract void pourSauce();

    public void fry(){
        System.out.println("炒菜");
    }
}
```

```java
package action.template;

/**
 * @ClassName ConcreteClass_BaoCai
 * @Author shuai
 * @create 2023/7/24 21:47
 * @Instruction 具体实现类：炒包菜
 */
public class ConcreteClass_BaoCai extends AbstractClass{
    @Override
    public void pourVegetable() {
        System.out.println("放入包菜");
    }

    @Override
    public void pourSauce() {
        System.out.println("放入辣椒和盐醋");

    }
}
```

```java
package action.template;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/24 21:49
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {
        ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai();
        baoCai.cookProcess();
    }
}
```



### 3.2.3 优缺点分析

优点：

+ 提高代码复用性
+ 子类是在父类功能上做拓展，实现反向控制

缺点：

类的数量在会不断增加



### 3.2.4 使用场景

+ 算法步骤很确定，但是个别部分容易改变
+ 通过子类确定父类中某个方法是否执行



### 3.2.5 jdk源码

```java
public abstract class InputStream implements Closeable {
    public abstract int read() throws IOException;
    
    public int read(byte b[]) throws IOException {
        return read(b, 0, b.length);
    }
    
    
    //就是一个模板
    public int read(byte b[], int off, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (off < 0 || len < 0 || len > b.length - off) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        }

        int c = read();
        if (c == -1) {
            return -1;
        }
        b[off] = (byte)c;

        int i = 1;
        try {
            for (; i < len ; i++) {
                c = read();
                if (c == -1) {
                    break;
                }
                b[off + i] = (byte)c;
            }
        } catch (IOException ee) {
        }
        return i;
    }

}
```



## 3.3 策略模式

### 3.3.1 概述

包括三部分：

+ 抽象策略类：通常是接口或者抽象类，给出具体角色所需接口
+ 具体策略类：实现抽象类接口，实现具体行为
+ 环境类：持有策略类的引用



### 3.3.2 案例

一家公司的促销活动，针对不同节日（春节，中秋，圣诞节）退出不同的促销活动。

![image-20230725091713091](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230725091713091.png)

抽象策略类：

```java
package action.strategy;

/**
 * @ClassName Strategy
 * @Author shuai
 * @create 2023/7/25 9:18
 * @Instruction  抽象策略类
 */
public interface Strategy {

    void show();
}
```



具体策略类：

```java
package action.strategy;

/**
 * @ClassName StrategyA
 * @Author shuai
 * @create 2023/7/25 9:19
 * @Instruction
 */
public class StrategyA implements Strategy{
    @Override
    public void show() {
        System.out.println("买一送一");
    }
}
```

```java
package action.strategy;

/**
 * @ClassName StrategyA
 * @Author shuai
 * @create 2023/7/25 9:19
 * @Instruction
 */
public class StrategyB implements Strategy{
    @Override
    public void show() {
        System.out.println("满200减50");
    }
}
```

```java
package action.strategy;

/**
 * @ClassName StrategyA
 * @Author shuai
 * @create 2023/7/25 9:19
 * @Instruction
 */
public class StrategyC implements Strategy{
    @Override
    public void show() {
        System.out.println("满1000加1元换购200元商品");
    }
}
```



环境类：

```java
package action.strategy;

/**
 * @ClassName SalesMan
 * @Author shuai
 * @create 2023/7/25 9:21
 * @Instruction 促销员，环境类
 */
public class SalesMan {

    private Strategy strategy;

    public SalesMan(Strategy strategy) {
        this.strategy = strategy;
    }

    //展示促销活动
    public void salesManShow(){
        strategy.show();
    }
}
```



客户端：

```java
package action.strategy;

/**
 * @ClassName Client
 * @Author shuai
 * @create 2023/7/25 9:23
 * @Instruction
 */
public class Client {
    public static void main(String[] args) {
        //春节来了，使用策略A
        SalesMan salesMan = new SalesMan(new StrategyA());
        salesMan.salesManShow();
    }
}
```

![image-20230725092628284](https://typora-rein.oss-cn-nanjing.aliyuncs.com/image-20230725092628284.png)



### 3.3.3 优缺点

优点：

+ 策略类可以自由切换
+ 易于拓展，增加策略类即可
+ 减少条件选择语句的使用

缺点：

+ 用户需要知道有哪些策略
+ 将会产生很多策略类



### 3.3.4 使用场景

+ 系统需要在几种算法中动态选择
+ 算法表现独立时



### 3.3.5 jdk源码

`Arrays.sort()`:传入的策略可以决定是升序还是降序排序，甚至可以自定义排序方式。

